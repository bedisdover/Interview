# 5.4 JVM 相关

### JVM 内存区域

- 线程共享
    - java 堆

    存储java实例或者对象

    - 方法区

    用于存储类结构信息的地方，包括(运行时)常量池、静态变量、构造函数

- 线程私有
    - JVM 栈
    - 本地方法栈
    - 程序计数器

### Java 堆的构成

- 新生代 Young Generation

    - Eden Space 任何新进入运行时数据区域的实例都会存放在此
    - S0 Suvivor Space 存在时间较长，经过垃圾回收没有被清除的实例，就从Eden 搬到了S0
    - S1 Suvivor Space 同S0

- 老年代 Old Generation/tenured

    存在时间更长的实例，对象多次回收没被清除，就从Suvivor 搬到了tenured

- 持久代 Perm

    存放运行时数据区的方法区

### JVM 垃圾检测

- 引用计数法

    给一个对象添加引用计数器，每当有个地方引用它，计数器就加1；引用失效就减1。引用计数为0的对象视为垃圾。

- 可达性分析

    以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象、本地方法中引用的对象等。

### JVM 垃圾回收算法

- 标记清除

    分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。标记清除算法带来的一个问题是会存在大量的空间碎片，因为回收后的空间是不连续的，这样给大对象分配内存的时候可能会提前触发full gc。

- 复制算法

    将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

- 标记整理

    标记-整理算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象整理到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。

### JVM 垃圾回收器

- Serial

    - 使用单线程进行垃圾回收
    - 需要中断所有的用户进程，直到回收结束，被称为 "Stop The World"

- ParNew

    - 多线程版本的 Serial，同样有 Stop The World 的问题
    - 是多CPU模式下的首选收集器，也是 Server 模式下的默认收集器

- Parallel Scavenge

    - 用于新生代的并行复制算法收集器
    - 吞吐量优先，可控制达到特定的吞吐量

- Parallel Old

    - 老年代并行收集器，使用标记整理算法、吞吐量优先

- CMS

    - 分为 初始标记、并发标记、并发预清理、重新标记、并发清理、并发重置 六个阶段
    - 使用标记清除算法的老年代收集器，对CPU要求高

- G1

    - 同时负责新生代和老年代的垃圾回收工作
    - 将堆内存划分为相等的内存块，使用复制算法，每次清理垃圾率高的区域

